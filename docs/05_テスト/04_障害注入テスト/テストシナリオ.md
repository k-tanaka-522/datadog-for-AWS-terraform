# 障害注入テストシナリオ

## 1. ドキュメント情報

| 項目 | 内容 |
|------|------|
| プロジェクト名 | Datadog for AWS Terraform PoC |
| フェーズ | 障害注入テスト |
| バージョン | 1.3 |
| 作成日 | 2025-12-28 |
| 作成者 | QA |
| ステータス | Draft |

---

## 2. 概要

障害注入テストでは、各レイヤー（**L0/L1/L2/L3**の4層）で意図的に障害を発生させ、Datadog Monitorが正しくアラートを発火することを確認します。また、障害解消後のリカバリーも検証します。

**4層監視モデル**:

| レイヤー | 監視対象 | PoC実装状況 |
|---------|---------|------------|
| **L0（ネットワーク）** | VPC Flow Logs、RDS/ECS（将来L1へ移行予定）、Datadog Agent | ✅ 実装済み |
| **L1（コンピュート）** | RDS、ECS、ALB（将来移行） | ⚠️ 将来拡張 |
| **L2（サービス）** | E2Eヘルスチェック、ECR脆弱性 | ✅ 実装済み |
| **L3（テナント）** | テナント別監視（12個: 3テナント × 4 Monitor: Synthetics + APM Error + Log Error + Latency） | ✅ 実装済み |

---

## 3. L0レイヤー障害注入シナリオ（ネットワーク層）

### 3.1 前提条件

- [ ] 全Monitorのステータスが「OK」
- [ ] AWS環境が正常稼働中

### 3.2 シナリオ: L0-VPC-Flow（VPC Flow Logs異常）

#### 手順

**ステップ1: 初期状態確認**
```bash
# Datadog UI確認
# Monitors > Manage Monitors > L0-VPC-Flow
# ステータス: OK
```

**ステップ2: VPC Flow Logs異常シミュレーション**
```bash
# Datadog API経由でログを送信（rejected packetを模擬）
curl -X POST "https://http-intake.logs.datadoghq.com/v1/input/${DD_API_KEY}" \
  -H "Content-Type: application/json" \
  -d '{
    "ddsource": "vpc-flow-logs",
    "message": "REJECT test-packet",
    "status": "reject",
    "timestamp": "'"$(date +%s)"'"
  }'
```

**ステップ3: 5分待機**
```bash
# Monitor評価間隔を考慮
sleep 300
```

**ステップ4: Monitor確認**
```bash
# Datadog UI確認
# L0-VPC-Flow のステータス: ALERT
# Event Stream に通知記録
```

**ステップ5: リカバリー（正常値送信）**
```bash
# 正常なログを送信
curl -X POST "https://http-intake.logs.datadoghq.com/v1/input/${DD_API_KEY}" \
  -H "Content-Type: application/json" \
  -d '{
    "ddsource": "vpc-flow-logs",
    "message": "ACCEPT normal-packet",
    "status": "accept",
    "timestamp": "'"$(date +%s)"'"
  }'
```

**ステップ6: リカバリー確認**
```bash
# 5分待機後
# L0-VPC-Flow のステータス: OK
```

#### 期待結果

| ステップ | 期待結果 |
|--------|---------|
| ステップ4 | L0-VPC-Flow: ALERT、通知送信 |
| ステップ6 | L0-VPC-Flow: OK、リカバリー通知送信 |

---

### 3.3 シナリオ: L0-RDS-CPU（RDS CPU高負荷、将来L1へ移行予定）

**⚠️ PoC段階ではL0に含まれる（将来L1に移行予定）**

#### 手順

**ステップ1: 初期状態確認**
```bash
# Datadog UI確認
# Monitors > Manage Monitors > L0-RDS-CPU
# ステータス: OK
```

**ステップ2: RDS CPU高負荷シミュレーション**
```bash
curl -X POST "https://api.datadoghq.com/api/v1/series" \
  -H "Content-Type: application/json" \
  -H "DD-API-KEY: ${DATADOG_API_KEY}" \
  -d '{
    "series": [{
      "metric": "aws.rds.cpuutilization",
      "points": [['"$(date +%s)"', 95]],
      "type": "gauge",
      "host": "rds-instance-id",
      "tags": ["env:poc"]
    }]
  }'
```

**ステップ3: 5分待機**
```bash
# Monitor評価間隔を考慮
sleep 300
```

**ステップ4: Monitor確認**
```bash
# Datadog UI確認
# L0-RDS-CPU のステータス: ALERT
# Event Stream に通知記録
```

**ステップ5: リカバリー（正常値送信）**
```bash
curl -X POST "https://api.datadoghq.com/api/v1/series" \
  -H "Content-Type: application/json" \
  -H "DD-API-KEY: ${DATADOG_API_KEY}" \
  -d '{
    "series": [{
      "metric": "aws.rds.cpuutilization",
      "points": [['"$(date +%s)"', 20]],
      "type": "gauge",
      "host": "rds-instance-id",
      "tags": ["env:poc"]
    }]
  }'
```

**ステップ6: リカバリー確認**
```bash
# 5分待機後
# L0-RDS-CPU のステータス: OK
```

#### 期待結果

| ステップ | 期待結果 |
|--------|---------|
| ステップ4 | L0-RDS-CPU: ALERT、通知送信 |
| ステップ6 | L0-RDS-CPU: OK、リカバリー通知送信 |

---

### 3.4 シナリオ: L0-ECS-Tasks（ECS Task異常停止、将来L1へ移行予定）

**⚠️ PoC段階ではL0に含まれる（将来L1に移行予定）**

#### 手順

**ステップ1: 現在のECS Task数確認**
```bash
aws ecs list-tasks --cluster ${CLUSTER_NAME} --service-name demo-api
```

**ステップ2: ECS Task停止**
```bash
aws ecs stop-task --cluster ${CLUSTER_NAME} --task ${TASK_ARN} --reason "Testing L0 Monitor"
```

**ステップ3: 5分待機**

**ステップ4: Monitor確認**
```bash
# Datadog UI確認
# L0-ECS-Tasks のステータス: ALERT
```

**ステップ5: リカバリー（ECS Task自動再起動を待機）**
```bash
# ECS Service の desired count により自動再起動
# または手動で再起動:
aws ecs update-service --cluster ${CLUSTER_NAME} --service demo-api --force-new-deployment
```

**ステップ6: リカバリー確認**
```bash
# L0-ECS-Tasks のステータス: OK
```

---

### 3.5 シナリオ: L0-Agent（Datadog Agent停止）

#### 手順

**ステップ1: Datadog Agent Task確認**
```bash
aws ecs list-tasks --cluster ${CLUSTER_NAME} --service-name datadog-agent
```

**ステップ2: Datadog Agent Task停止**
```bash
aws ecs stop-task --cluster ${CLUSTER_NAME} --task ${AGENT_TASK_ARN} --reason "Testing L0 Monitor"
```

**ステップ3: 5分待機**

**ステップ4: Monitor確認**
```bash
# L0-Agent のステータス: ALERT
```

**ステップ5: リカバリー（Agent再起動）**
```bash
aws ecs update-service --cluster ${CLUSTER_NAME} --service datadog-agent --desired-count 1
```

**ステップ6: リカバリー確認**
```bash
# L0-Agent のステータス: OK
```

---

## 4. L1レイヤー障害注入シナリオ（コンピュート層、将来拡張）

**⚠️ PoC段階では未実装（RDS、ECS、ALB監視はL0に含まれる）**

### 4.1 将来実装時のシナリオ: L1-RDS-CPU（RDS CPU高負荷）

**将来実装時の動作**:
1. RDS CPU使用率が95%を超える → L1-RDS-CPU が ALERT
2. L1-Composite が ALERT（L1-RDS-CPU がトリガー）
3. 派生的に、E2Eヘルスチェック失敗 → L2-E2E-Health が ALERT
4. 派生的に、tenant-a のエラーログが増加 → L3-Error-tenant-a が ALERT

**Composite Monitor の判定（将来）**:
- L0-Composite: OK（L0は正常）
- L1-Composite: ALERT（通知する）
- L2-Composite: `(L2-E2E-Health = ALERT) && NOT L0-Composite && NOT L1-Composite` → FALSE（通知しない）
- L3-Composite-tenant-a: `(L3-Error-tenant-a = ALERT) && NOT L0-Composite && NOT L1-Composite && NOT L2-Composite` → FALSE（通知しない）

**結果**: L1-Composite のアラートのみ通知。

---

## 5. L2レイヤー障害注入シナリオ（サービス層）

### 5.1 シナリオ: L2-E2E-Health（E2Eヘルスチェック失敗、FR-002-5）

#### 手順

**ステップ1: グローバルヘルスチェック確認**
```bash
curl -X GET https://${ALB_DNS}/health
# HTTP 200, {"status": "ok"}
```

**ステップ2: ECS Task全停止（サービス停止）**
```bash
aws ecs update-service --cluster ${CLUSTER_NAME} --service demo-api --desired-count 0
```

**ステップ3: ヘルスチェック失敗確認**
```bash
curl -X GET https://${ALB_DNS}/health
# HTTP 503 Service Unavailable（またはタイムアウト）
```

**ステップ4: Monitor確認**
```bash
# L2-E2E-Health のステータス: ALERT
```

**ステップ5: リカバリー**
```bash
aws ecs update-service --cluster ${CLUSTER_NAME} --service demo-api --desired-count 2
```

**ステップ6: リカバリー確認**
```bash
curl -X GET https://${ALB_DNS}/health
# HTTP 200, {"status": "ok"}
# L2-E2E-Health のステータス: OK
```

---

### 5.2 シナリオ: L2-ECR-Vuln（ECR脆弱性検出）

#### 手順

**ステップ1: 初期状態確認**
```bash
# Datadog UI確認
# Monitors > Manage Monitors > L2-ECR-Vuln
# ステータス: OK
```

**ステップ2: 脆弱性シミュレーション（Datadog API経由）**
```bash
curl -X POST "https://api.datadoghq.com/api/v1/series" \
  -H "Content-Type: application/json" \
  -H "DD-API-KEY: ${DATADOG_API_KEY}" \
  -d '{
    "series": [{
      "metric": "aws.ecr.vulnerability.critical",
      "points": [['"$(date +%s)"', 1]],
      "type": "gauge",
      "tags": ["repository_name:myapp"]
    }]
  }'
```

**ステップ3: Monitor確認**
```bash
# L2-ECR-Vuln のステータス: ALERT
```

**ステップ4: リカバリー（脆弱性修正、イメージ更新）**
```bash
curl -X POST "https://api.datadoghq.com/api/v1/series" \
  -H "Content-Type: application/json" \
  -H "DD-API-KEY: ${DATADOG_API_KEY}" \
  -d '{
    "series": [{
      "metric": "aws.ecr.vulnerability.critical",
      "points": [['"$(date +%s)"', 0]],
      "type": "gauge",
      "tags": ["repository_name:myapp"]
    }]
  }'
```

**ステップ5: リカバリー確認**
```bash
# L2-ECR-Vuln のステータス: OK
```

---

## 6. L3レイヤー障害注入シナリオ（テナント層）

### 6.1 シナリオ: L3-Error-tenant-a（エラーログ）

#### 手順

**ステップ1: 初期状態確認**
```bash
# Datadog Logs確認
# フィルタ: service:demo-api tenant_id:tenant-a status:error
# 結果: 0件
```

**ステップ2: エラーシミュレーション実行**
```bash
curl -X POST https://${ALB_DNS}/tenant-a/simulate/error \
  -H "Content-Type: application/json" \
  -d '{"count": 10, "message": "Simulated error for testing"}'
```

**ステップ3: Datadog Logs確認**
```bash
# Datadog Logs
# フィルタ: service:demo-api tenant_id:tenant-a status:error
# 結果: 10件以上
```

**ステップ4: Monitor確認**
```bash
# L3-Error-tenant-a のステータス: ALERT
```

**ステップ5: リカバリー（エラー停止、時間経過）**
```bash
# エラーシミュレーションを停止
# 5分待機（エラーログが閾値以下に減少）
```

**ステップ6: リカバリー確認**
```bash
# L3-Error-tenant-a のステータス: OK
```

---

### 6.2 シナリオ: L3-Latency-tenant-a（レイテンシ）

#### 手順

**ステップ1: 初期状態確認**
```bash
# Datadog APM確認
# demo-api サービス > p99レイテンシ < 1秒
```

**ステップ2: レイテンシシミュレーション実行（10回繰り返し）**
```bash
for i in {1..10}; do
  curl -X POST https://${ALB_DNS}/tenant-a/simulate/latency \
    -H "Content-Type: application/json" \
    -d '{"duration_ms": 2000}'
  sleep 1
done
```

**ステップ3: Datadog APM確認**
```bash
# demo-api サービス > p99レイテンシ > 1秒
```

**ステップ4: Monitor確認**
```bash
# L3-Latency-tenant-a のステータス: ALERT
```

**ステップ5: リカバリー（レイテンシシミュレーション停止）**
```bash
# 5分待機（p99レイテンシが閾値以下に減少）
```

**ステップ6: リカバリー確認**
```bash
# L3-Latency-tenant-a のステータス: OK
```

---

### 6.3 シナリオ: L3-Health-tenant-a（ヘルスチェック失敗）

#### 手順

**ステップ1: 初期状態確認**
```bash
curl -X GET https://${ALB_DNS}/tenant-a/health
# HTTP 200, {"status": "ok", "tenant_id": "tenant-a"}
```

**ステップ2: ヘルスチェック無効化（テスト用）**
```bash
# 手動でL3 MonitorをALERT状態に設定（Datadog UI）
# または、demo-apiに/admin/disable-healthエンドポイントがあれば使用
```

**ステップ3: Monitor確認**
```bash
# L3-Health-tenant-a のステータス: ALERT
```

**ステップ4: リカバリー**
```bash
# 手動でL3 MonitorをOK状態に戻す
```

---

### 6.4 シナリオ: L3-APM-Error-tenant-a（APMエラー監視）

#### 手順

**ステップ1: 初期状態確認**
```bash
# Datadog UI確認
# Monitors > Manage Monitors > [L3 APM] tenant-a エラー数
# ステータス: OK
```

**ステップ2: エラーシミュレーション実行**
```bash
# APMトレースにエラーを記録させる
curl -X POST https://${ALB_DNS}/tenant-a/simulate/error \
  -H "Content-Type: application/json" \
  -d '{"count": 10, "message": "Simulated error for APM testing"}'
```

**ステップ3: 5分待機**
```bash
# Monitor評価間隔を考慮
sleep 300
```

**ステップ4: Monitor確認**
```bash
# [L3 APM] tenant-a エラー数 のステータス: ALERT
```

**ステップ5: リカバリー（エラー停止、時間経過）**
```bash
# エラーシミュレーションを停止
# 5分待機（APMエラーカウントが閾値以下に減少）
```

**ステップ6: リカバリー確認**
```bash
# [L3 APM] tenant-a エラー数 のステータス: OK
```

#### 期待結果

| ステップ | 期待結果 |
|--------|---------|
| ステップ4 | [L3 APM] tenant-a エラー数: ALERT、通知送信 |
| ステップ6 | [L3 APM] tenant-a エラー数: OK、リカバリー通知送信 |

#### Monitor詳細
- **クエリ**: `sum(last_5m):default_zero(sum:trace.fastapi.request.errors{service:demo-api}.as_count()) > 5`
- **タイプ**: Metric Alert
- **notify_no_data**: false（`default_zero()`でNo Data回避）

---

### 6.5 シナリオ: L3-Log-Error-tenant-a（ログエラー監視）

#### 手順

**ステップ1: 初期状態確認**
```bash
# Datadog Logs確認
# フィルタ: service:demo-api status:error
# 結果: 0件（または閾値以下）
```

**ステップ2: エラーシミュレーション実行**
```bash
curl -X POST https://${ALB_DNS}/tenant-a/simulate/error \
  -H "Content-Type: application/json" \
  -d '{"count": 10, "message": "Simulated error for Log testing"}'
```

**ステップ3: Datadog Logs確認**
```bash
# Datadog Logs
# フィルタ: service:demo-api status:error
# 結果: 10件以上
```

**ステップ4: Monitor確認**
```bash
# [L3 Log] tenant-a エラーログ数 のステータス: ALERT
```

**ステップ5: リカバリー（エラー停止、時間経過）**
```bash
# エラーシミュレーションを停止
# 5分待機（エラーログが閾値以下に減少）
```

**ステップ6: リカバリー確認**
```bash
# [L3 Log] tenant-a エラーログ数 のステータス: OK
```

#### 期待結果

| ステップ | 期待結果 |
|--------|---------|
| ステップ3 | Datadog Logsにエラーログが表示される |
| ステップ4 | [L3 Log] tenant-a エラーログ数: ALERT |
| ステップ6 | [L3 Log] tenant-a エラーログ数: OK |

#### Monitor詳細
- **クエリ**: `logs("status:error service:demo-api").rollup("count").last("5m") > 5`
- **タイプ**: Log Alert
- **notify_no_data**: false

---

### 6.6 シナリオ: Composite抑制検証（POC核心）

**目的**: L1/L2障害発生時にL3アラート（APM Error + Log Error）が抑制されることを確認。これがPOCの最重要検証項目。

#### 手順

**ステップ1: 初期状態確認**
```bash
# 全Monitorのステータスが「OK」であることを確認
# Datadog > Monitors > Manage Monitors
```

**ステップ2: L1障害シミュレーション（RDS接続断）**
```bash
# 方法A: Security GroupでRDSへの接続を遮断
aws ec2 revoke-security-group-ingress \
  --group-id ${RDS_SG_ID} \
  --protocol tcp \
  --port 5432 \
  --source-group ${ECS_SG_ID}

# 方法B: RDSインスタンス停止（非推奨：復旧に時間がかかる）
aws rds stop-db-instance --db-instance-identifier ${RDS_INSTANCE_ID}
```

**ステップ3: 派生障害発生確認（5分待機）**
```bash
# 以下のMonitorがALERTになることを確認:
# - L1-RDS-CPU/Conn/Mem/Storage のいずれか → ALERT
# - L2-E2E-Health → ALERT（/health が 500 返却）
# - [L3 APM] tenant-a エラー数 → ALERT（DB接続エラー急増）
# - [L3 Log] tenant-a エラーログ数 → ALERT（エラーログ急増）
```

**ステップ4: Composite Monitor確認**
```bash
# Datadog > Monitors > Manage Monitors > フィルタ: tag:composite:true

# L1-Composite: ALERT（通知送信される）
# L2-Composite: ALERT（通知抑制される）← NOT L1-Composite により
# L3-Composite-tenant-a: ALERT（通知抑制される）← NOT L1-Composite により
```

**ステップ5: Event Stream確認**
```bash
# Datadog > Events
# 確認: L1-Compositeの通知のみが送信されている
# 確認: L2-Composite、L3-Compositeの通知は送信されていない
```

**ステップ6: リカバリー**
```bash
# 方法A: Security Group復旧
aws ec2 authorize-security-group-ingress \
  --group-id ${RDS_SG_ID} \
  --protocol tcp \
  --port 5432 \
  --source-group ${ECS_SG_ID}

# 方法B: RDSインスタンス起動
aws rds start-db-instance --db-instance-identifier ${RDS_INSTANCE_ID}
```

**ステップ7: リカバリー確認（10分待機）**
```bash
# 全MonitorがOKに戻ることを確認
```

#### 期待結果

| Monitor | 状態 | 通知 | 理由 |
|---------|------|------|------|
| L1-Composite | ALERT | ✅ 送信 | 根本原因（RDS障害）を通知 |
| L2-Composite | ALERT | ❌ 抑制 | `NOT L1-Composite` により抑制 |
| L3-Composite-tenant-a | ALERT | ❌ 抑制 | `NOT L1-Composite` により抑制 |

**POC成功基準**: L1-Compositeのみが通知され、L2/L3は抑制される

---

## 7. Composite Monitor検証シナリオ（4層因果関係）

### 7.1 シナリオ: L0-Composite（L0レイヤー障害集約）

#### 手順

**ステップ1: L0 Monitor（いずれか）をALERT状態に設定**
```bash
# L0-VPC-Flow をALERT状態に設定（シナリオ3.2参照）
```

**ステップ2: Composite Monitor確認**
```bash
# L0-Composite のステータス: ALERT
# 式: L0-VPC-Flow || L0-RDS-CPU || ... のいずれかがALERT → Composite ALERT
```

**ステップ3: Event Stream確認**
```bash
# L0-Composite の通知が送信されている
```

---

### 7.2 シナリオ: L1-Composite（L1レイヤー障害集約、将来実装）

**⚠️ PoC段階では未実装（RDS、ECS監視がL0に含まれるため）**

**将来実装時の動作**:
1. L1 Monitor（いずれか）をALERT状態に設定 → L1-Composite が ALERT
2. L0-Composite確認 → OK（L0は正常）
3. L2-Composite確認 → `(L2-E2E-Health = ALERT) && NOT L0-Composite && NOT L1-Composite` → FALSE（通知しない）
4. Event Stream確認 → L1-Composite の通知のみ送信

---

### 7.3 シナリオ: L2-Composite（L2レイヤー障害集約、L0/L1正常時のみ通知）

#### 手順

**ステップ1: L2 Monitor（いずれか）をALERT状態に設定**
```bash
# L2-E2E-Health をALERT状態に設定（シナリオ5.1参照）
```

**ステップ2: L0-Composite確認**
```bash
# L0-Composite のステータス: OK（L0は正常）
```

**ステップ3: Composite Monitor確認**
```bash
# L2-Composite のステータス: ALERT
# 式: (L2-E2E-Health || L2-ECR-Vuln) && NOT L0-Composite → Composite ALERT
```

**ステップ4: Event Stream確認**
```bash
# L2-Composite の通知が送信されている
```

**ステップ5: L0障害発生（追加テスト）**
```bash
# L0-VPC-Flow をALERT状態に設定
```

**ステップ6: Composite Monitor再確認**
```bash
# L0-Composite のステータス: ALERT
# L2-Composite のステータス: ALERT（ただし通知抑制、NOT L0-Composite により）
```

**ステップ7: Event Stream確認**
```bash
# L0-Composite の通知のみ送信
# L2-Composite の通知は抑制
```

---

### 7.4 シナリオ: L3-Composite-tenant-a（L3レイヤー障害集約、L0/L1/L2正常時のみ通知）

#### 手順

**ステップ1: L3 Monitor（tenant-a、いずれか）をALERT状態に設定**
```bash
# L3-Error-tenant-a をALERT状態に設定（シナリオ6.1参照）
```

**ステップ2: L0/L2-Composite確認**
```bash
# L0-Composite のステータス: OK
# L2-Composite のステータス: OK
```

**ステップ3: Composite Monitor確認**
```bash
# L3-Composite-tenant-a のステータス: ALERT
# 式: (FR-003-1 OR L3-APM-Error-tenant-a OR L3-Log-Error-tenant-a OR L3-Latency-tenant-a) AND NOT L0-Composite AND NOT L1-Composite AND NOT L2-Composite → Composite ALERT
```

**ステップ4: Event Stream確認**
```bash
# L3-Composite-tenant-a の通知が送信されている
```

**ステップ5: L0障害発生（追加テスト）**
```bash
# L0-VPC-Flow をALERT状態に設定
```

**ステップ6: Composite Monitor再確認**
```bash
# L0-Composite のステータス: ALERT
# L3-Composite-tenant-a のステータス: ALERT（ただし通知抑制、NOT L0-Composite により）
```

**ステップ7: Event Stream確認**
```bash
# L0-Composite の通知のみ送信
# L3-Composite-tenant-a の通知は抑制
```

---

## 8. サービスマップ検証シナリオ（APM連携）

### 8.1 前提条件

- [ ] Unified Service Tagging設定済み（DD_SERVICE, DD_ENV, DD_VERSION）
- [ ] APMトレーシング有効化済み
- [ ] Datadog Agent サイドカー稼働中

### 8.2 シナリオ: サービスマップ表示確認

#### 手順

**ステップ1: サービスマップ表示確認**
```bash
# Datadog UI確認
# APM > Service Map
# demo-api が表示されることを確認
```

**ステップ2: 依存関係確認**
```bash
# Service Map上で
# demo-api → RDS（postgresql）への矢印が表示されることを確認
```

**ステップ3: Service Catalog確認**
```bash
# APM > Service Catalog
# demo-api の詳細を確認
# - env: poc
# - version: 1.0.0
```

#### 期待結果

| ステップ | 期待結果 |
|--------|---------|
| ステップ1 | demo-api がService Mapに表示される |
| ステップ2 | demo-api → RDS の依存関係が矢印で表示される |
| ステップ3 | env:poc, version:1.0.0 のタグが確認できる |

---

### 8.3 シナリオ: トレース追跡確認

#### 手順

**ステップ1: 正常リクエスト送信**
```bash
curl -X GET https://${ALB_DNS}/tenant-a/items
```

**ステップ2: APMトレース確認**
```bash
# Datadog UI確認
# APM > Traces
# フィルタ: service:demo-api resource_name:GET /tenant-a/items
```

**ステップ3: スパン詳細確認**
```bash
# トレースを選択し、以下を確認:
# - fastapi.request（APIエンドポイント）
# - postgresql.query（RDSクエリ）
```

#### 期待結果

| ステップ | 期待結果 |
|--------|---------|
| ステップ2 | トレースが記録されている |
| ステップ3 | fastapi.request → postgresql.query のスパン階層が確認できる |

---

### 8.4 シナリオ: エラートレース追跡

#### 手順

**ステップ1: エラーシミュレーション実行**
```bash
curl -X POST https://${ALB_DNS}/tenant-a/simulate/error \
  -H "Content-Type: application/json" \
  -d '{"count": 1, "message": "Test error for trace"}'
```

**ステップ2: APMエラートレース確認**
```bash
# APM > Traces
# フィルタ: service:demo-api status:error
```

**ステップ3: エラー箇所特定**
```bash
# トレースを選択し、エラー発生箇所を確認
# - エラーメッセージ
# - スタックトレース
# - 関連するスパン
```

#### 期待結果

| ステップ | 期待結果 |
|--------|---------|
| ステップ2 | エラートレースが記録されている |
| ステップ3 | エラー発生箇所（simulate/error エンドポイント）が特定できる |

---

### 8.5 シナリオ: 障害時のサービスマップ影響確認

#### 手順

**ステップ1: L0障害発生（RDS CPU高負荷シミュレーション）**
```bash
# シナリオ3.3参照
```

**ステップ2: サービスマップ確認**
```bash
# APM > Service Map
# demo-api → RDS の接続状態を確認
```

**ステップ3: 障害の影響範囲確認**
```bash
# Service Map上でエラー率の変化を確認
# demo-api のヘルスステータスを確認
```

#### 期待結果

| ステップ | 期待結果 |
|--------|---------|
| ステップ2 | Service Map上でRDSへの接続異常が可視化される |
| ステップ3 | demo-apiのエラー率上昇が確認できる |

---

## 9. リカバリーテストシナリオ

### 9.1 シナリオ: 全レイヤー障害発生→リカバリー（4層モデル）

#### 手順

**ステップ1: L0/L2/L3障害発生**
```bash
# L0-VPC-Flow: ALERT
# L2-E2E-Health: ALERT
# L3-Error-tenant-a: ALERT
```

**ステップ2: Composite Monitor確認**
```bash
# L0-Composite: ALERT（通知送信）
# L2-Composite: ALERT（通知抑制）
# L3-Composite-tenant-a: ALERT（通知抑制）
```

**ステップ3: L0障害解消**
```bash
# L0-VPC-Flow をOK状態に戻す
# リカバリー開始時刻記録
```

**ステップ4: 5分待機**

**ステップ5: L0-Composite復旧確認**
```bash
# L0-Composite のステータス: OK
# リカバリー完了時刻記録
# リカバリー時間計算: 完了時刻 - 開始時刻 < 5分
```

**ステップ6: L2-Composite通知確認**
```bash
# L2-Composite の通知が送信される（L0-Compositeが復旧したため）
```

**ステップ7: L2障害解消**
```bash
# L2-E2E-Health をOK状態に戻す
```

**ステップ8: L3-Composite通知確認**
```bash
# L3-Composite-tenant-a の通知が送信される（L0/L2-Compositeが復旧したため）
```

**ステップ9: L3障害解消**
```bash
# L3-Error-tenant-a をOK状態に戻す
```

**ステップ10: 全Monitor正常確認**
```bash
# 全Monitor（L0: 7個、L2: 2個、L3: 12個、Composite: 3個）のステータス: OK
# ⚠️ L1-Composite は未実装（PoC範囲外）
```

#### 期待結果

| ステップ | 期待結果 |
|--------|---------|
| ステップ2 | L0-Composite のみ通知 |
| ステップ5 | L0-Composite 復旧（5分以内） |
| ステップ6 | L2-Composite 通知 |
| ステップ8 | L3-Composite 通知 |
| ステップ10 | 全Monitor OK（L1を除く） |

---

## 10. 合格判定

### 10.1 合格条件（PoC実装範囲）

**以下の全条件を満たす場合、障害注入テスト合格と判定**:
- [ ] L0 Monitor（7個）: 全てALERT状態遷移
- [ ] **L1 Monitor（0個）**: 将来拡張（PoC範囲外）
- [ ] L2 Monitor（2個）: 全てALERT状態遷移
- [ ] L3 Monitor（12個: 3テナント × 4 Monitor: Synthetics + APM Error + Log Error + Latency）: 全てALERT状態遷移
- [ ] Composite Monitor（3個: L0/L2/L3）: 親子関係が正しく動作
- [ ] サービスマップ検証: demo-api がService Mapに表示され、RDS依存関係が可視化される
- [ ] トレース追跡: リクエストがRDSクエリまで追跡できる
- [ ] エラー追跡: エラー発生箇所がトレースで特定できる
- [ ] リカバリー時間: 5分以内
- [ ] Critical/High不具合: 0件

---

## 11. 改訂履歴

| 日付 | バージョン | 変更内容 | 作成者 |
|------|-----------|----------|--------|
| 2025-12-28 | 1.0 | 初版作成 | QA |
| 2025-12-31 | 1.1 | 4層モデル（L0/L1/L2/L3）に対応、L1層を将来拡張として位置づけ、PoC実装範囲明記 | QA |
| 2025-12-31 | 1.2 | §8 サービスマップ検証シナリオ追加、合格条件にサービスマップ検証を追加 | QA |
| 2025-12-31 | 1.3 | L3監視構成変更を反映（APM Error、Log Error追加）、§6.4-6.6 シナリオ追加、POC核心検証シナリオ追加 | QA |

---

**承認欄**:

| 役割 | 氏名 | 承認日 | サイン |
|------|------|--------|--------|
| QA | QAエージェント | 2025-12-31 | ✅ |
| PM | PMエージェント |  |  |
